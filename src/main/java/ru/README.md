# shop

Знания какие-то есть уже по JAVA, но смотришь на лекции, да и вообще на весь учебный материал в интернете, и понимаешь, что совсем еще мало знаешь для программирования.

Конечно, можно решать задачи по программированию, которые найдешь в инете: олимпиадные, какой-нибудь компании и т.п. Но хочется реального проекта...

Так и начнем пилить реальный проект)

Круг моих текущих рабочих обязанностей пронизан необходимостью учета всего происходящего: складской учет, кадровый, учет выполненных задач и прочее. Вот отсюда и вырос кристал идей первого реального проекта: учет, мазафака!

Решил начать именно с того, что знаю (думаю, что знаю):
	1) будем банально вести учет имеющихся товаров, без отражения движения, без комментариев, просто с выводом таблицы в консоль того товара, который есть, а потом будем улучшать

	2) каждый товар будет представлен объектом соответствующего класса (Product): есть наименование (name), артикул (id), цена (price)

	3) вся работа будет происходить в консоли: консоль будет спрашивать, что делать, и просить ввести какие-нибудь данные для какого-либо действия

	4) в коде должны быть комментарии, чтоб отслеживать свои рассуждения на тот момент: типа, чем руководствовался, когда писал такой код (на первых порах руководствуюсь исключительно имеющимися знаниями)

	5) не пытаться сделать сразу универсальный код, можно делать и костыли, зато знаешь, что в этом месте можно и эффективнее написать, в такие моменты написать комментарий, да и вообще вести отдельный файл, где указывать своё видение будущего проекта и возможных изменений, а эти изменения и будут побуждать изучить какие-то дополнительные нюансы JAVA

13.12.17
	Нужно было сравнивать продукты и не хотелось заморачиваться с писаниной для сравнения каждого поля объекта, поэтому переопределил метод equals().
		При определении необходимо было сравнить ссылки на равенство, убедиться, что сслыка != null, что сравниваемые объекты одного типа, а затем создать экземпеляр сравниваемого объекта с типом вызывающего метод объекта и сравнить поля, идентифицирующие объект.
	Думал, что проблема при сравнении элементов массива с введеным объектом заключается в переопределенном методе equals(), но потом задал вопрос на slack по особенностям работы циклов for и for each.
		Оказалось, что for each работает с копиями элементов основного массива. Придется выборочно использовать циклы for и for each.

17.12.17
	Чтобы начать цикл заново, нужно использовать оператор continue.

21.12.17
	У класса Scanner есть метод .hasNextInt(), который вернет true, если с потока ввода можно считать целое число.
	Если после метода .nextInt() использовать метод .nextLine(), то метод .nextLine() считает последнее нажатие клавиши ENTER, как символ \n (перехода а новую строку). Поэтому после метода .nextInt() использовать метод .nextLine(), который считает нажатие клавиши ENTER и освободит буфер, а потом уже использовать метод .nextLine(), как задумывалось изначально.
	Метод .hasNextInt() можно использовать вместо использования исключений при проверке введеных пользователем данных.

07.01.18
	Maven установил через Homebrew(https://brew.sh/index_ru.html), введя в терминал комнду /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)". Потом руководствовался следующим http://www.apache-maven.ru/quick_start.html.
	При выполнении команды mvn compile выходила ошибка:
														Compilation failure: Compilation failure: 
														[ERROR] Source option 1.5 is no longer supported. Use 1.6 or later.
														[ERROR] Target option 1.5 is no longer supported. Use 1.6 or later.
														Эту проблему решил, добавив в pom.xml в теге <properties> следующие строки:
															<maven.compiler.source>1.6</maven.compiler.source>
    														<maven.compiler.target>1.6</maven.compiler.target>
    													И изменив название пакета с 1 на first
    При выполнении команды java -cp ./target/classes first.App все заработало.

07.01.18
	Создал проект maven в IDEA, нажав правой кнопкой мыши на имя проекта, потом выбрав New/Module/Maven.
	В корневом pom.xml добавил следующий тег:
												<dependencies>
											        <dependency>
											            <groupId>junit</groupId>
											            <artifactId>junit</artifactId>
											            <version>4.12</version>
											            <scope>test</scope>
											        </dependency>
											    </dependencies>
	Автоматически создали директории проекета maven. Меня интересовала директория test. В ней создал тестирующие классы с именами оригиналов + Test.
	Импортировал следующие библиотеки:
										import org.junit.Test;
										import static org.hamcrest.core.Is.is;
										import static org.junit.Assert.assertThat;

16.01.18
	Для освоения нового для себя направления решил изучить и использовать в своей программе некоторые структуры данных. Как оказалось есть несколько их видов: каждый из них эффективен в различных ситуациях. Соответственно встал вопрос: а какая у меня ситуация?

	Мне необходимо хранить что-то, что имеет описание и свой уникальный номер, порядок хранения не важен, элементы будут добавляться и удаляться, элементы нужно будет искать либо по точному описанию, либо по уникальному номеру.

	Решил, что подходящим способом хранения будет использование Map, а именно его реализацию в классе HashMap, т.к. расположение самих уникальных номеров и элементов по этим номерам не имеет значения.

21.01.18
	Забыл написать, как устанавливал Git к себе на Mac. Просто в терминале набрал xcode-select --install.
	Потом идет инициализация репозиория: имя_папки$ git init

	Осваиваю методы класса HashMap:

		Map<Integer, String> exampleHashMap = new HashMap();

        // добавление в множество пары ключ-значение
        exampleHashMap.put(1,"картошка");
        exampleHashMap.put(2,"морковка");

        System.out.println(exampleHashMap);

        // возвращает true, если коллекция содержит ключ k
        boolean beKey1 = exampleHashMap.containsKey(1);
        boolean beKey2 = exampleHashMap.containsKey(2);

        // возвращает true, если коллекция содержит значение v
        boolean beValuePotato = exampleHashMap.containsValue("картошка");

        // возвращает набор всех ключей множества
        Set keySet = exampleHashMap.keySet();

        // возвращает набор всех значений множества
        Collection values = exampleHashMap.values();
        

        System.out.println(beKey1 + " " + beKey2 + " " + beValuePotato + " " + keySet + " " + values);
    Столкнулся с тем, что в HashMap хранятся пары типа ключ-значение, а у меня продукт имеет следующие поля: имя, артикул, цена. Решил, что имя и артикул продукта будут парой ключ-значение, тогда, как поступить с ценой? Вот так: парой можно сделать продукт и его артикул, соответственно придется подумать, как под такую логику подогнать уже имеющуюся реализацию класса Product.

    	// удаляет объект с ключом k
        exampleHashMap.remove(potato.getId());

        // возвращает значение объекта, ключ которого равен k
        Product pot = exampleHashMap.get(potato.getId());

30.01.18
	Установил MySQL, следуя инструкции на сайте:
	https://vladster.net/ru/%D0%BA%D0%B0%D0%BA-%D1%83%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%B8%D1%82%D1%8C-mysql-%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80-%D0%BD%D0%B0-mac-os-x/
	1) сделал установку из предложенной ссылки (http://vladster.net/download/mysql-5.5.48-osx10.9-x86_64.dmg), а не последней версии с официалного сайта
	2) сделал: После завершения установки, откройте „System Preferences“ и вы увидите иконку MySQL. Нажмите на нее для открытия „preferences“  для MySQL сервера. После этого нажмите на клавишу „Start MySQL server“ для начала его работы. 
	3) для изменения пароля, который был установлен по умолчанию, переходим в директорию: cd /usr/local/mysql
	4) для изменения пароля, который был установлен по умолчанию, запуск скрипта для изменения пароля: sudo bin/mysql_secure_installation

	Войти в командную строку MySQL: /usr/local/mysql-5.5.48-osx10.8-x86_64/bin/mysql -u root -p;
	Здесь -u означает пользователя, а -p означает пароль. Обязательно заканчивать команду точкой с запятой.
	SHOW DATABASES;
	SHOW TABLES FROM testBase;
	SHOW COLUMNS FROM testBase; // покажет все столбцы указанной таблицы
	SELECT column_list FROM testBase; // покажет столбец column_list из таблицы testBase
	CREATE TABLE products (name VARCHAR(20), price SMALLINT(20), id SMALLINT(20)); // создание таблицы products с полем name, в котором тип хранимых данных VARCHAR, размер поля 20 и т.д.
	SELECT DISTINCT name FROM products ORDER BY name; // выбирает данные поля name без повторений (DISTINCT), затем сортирует (ORDER BY) по полю name
	SELECT * FROM products WHERE id = 222; // выбирает данные со всех полей (*), которые имеют поле id равное 222 (WHERE id = 222) 
	SHOW CHARACTER SET; // показывает кодировки, поддерживаемые установленной MySQL
	CREATE DATABASE unicodTest character set utf8; // создание базы данных с кодировкой utf8 (character set utf8)
	DROP DATABASE products; // удаление базы данных
	USE testBase; // выбор базы данных для работы
	LOAD DATA LOCAL INFILE "/Users/cladendas/Desktop/testTable.txt" INTO TABLE products; // импорт данных в таблицу из файла

	http://slusar.su/uroki/izuchaem-sql-vse-uroki/
	http://www.mysql.ru/docs/man/mysqlimport.html

	INSERT INTO products VALUES('виноград','444','66'); // добавление новой строки в таблицу
	DELETE FROM products WHERE name='виноград' // удаление строки, в которой столбец имеет запись 'виноград'
	DELETE FROM products; // удаление всех записей из таблицы
	UPDATE products SET id = '666' WHERE name = 'капуста'; // изменение значения в столбце id в строке со значением 'капуста'

03.02.18
	Как подключаться к базе MySQL:
		1) как я понял в JAVA есть драйвер доступа к базам данных JDBC, который способен сам понять, с какой базой данных работать
		2) драйвер JDBC можно использовать в проекте maven, прописав зависимость в pom.xml:
			<dependency>
            	<groupId>mysql</groupId>
            	<artifactId>mysql-connector-java</artifactId>
            	<version>5.1.36</version>
        	</dependency>
        3) в необходимом классе добавить импорт библиотеки для работы с SQL:
        	import java.sql.*;
        4) вся работа с базой данных ведется в блоке try-catch
        5) в указанном блоке делается подключение в базе данных:
        	подключение к базе с указанием протокола:подпротокола://[хоста]:[порта_СУБД]/[БД]
        	Connection connection = null;
        	connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/testBase","root", "1234");
        6) создается объект для SQl запросов без параметром:
        	Statement statement = null;
            statement = connection.createStatement();
        7) выполняется запрос
            ResultSet rs = statement.executeQuery("SELECT * FROM products");
        8) пример вывода данных:
        	// цикл для вывода каждой строки таблицы
            // метод next() используется для перехода к следующей строке
            while(rs.next()){
                for (int i = 1; i <= columns; i++){
                    // вывод данных каждого столбца-строки
                    System.out.print(rs.getString(i) + "\t");
                }
                System.out.println();
            }
