# shop

Знания какие-то есть уже по JAVA, но смотришь на лекции, да и вообще на весь учебный материал в интернете, и понимаешь, что совсем еще мало знаешь для программирования.

Конечно, можно решать задачи по программированию, которые найдешь в инете: олимпиадные, какой-нибудь компании и т.п. Но хочется реального проекта...

Так и начнем пилить реальный проект)

Круг моих текущих рабочих обязанностей пронизан необходимостью учета всего происходящего: складской учет, кадровый, учет выполненных задач и прочее. Вот отсюда и вырос кристал идей первого реального проекта: учет, мазафака!

Решил начать именно с того, что знаю (думаю, что знаю):
	1) будем банально вести учет имеющихся товаров, без отражения движения, без комментариев, просто с выводом таблицы в консоль того товара, который есть, а потом будем улучшать

	2) каждый товар будет представлен объектом соответствующего класса (Product): есть наименование (name), артикул (id), цена (price)

	3) вся работа будет происходить в консоли: консоль будет спрашивать, что делать, и просить ввести какие-нибудь данные для какого-либо действия

	4) в коде должны быть комментарии, чтоб отслеживать свои рассуждения на тот момент: типа, чем руководствовался, когда писал такой код (на первых порах руководствуюсь исключительно имеющимися знаниями)

	5) не пытаться сделать сразу универсальный код, можно делать и костыли, зато знаешь, что в этом месте можно и эффективнее написать, в такие моменты написать комментарий, да и вообще вести отдельный файл, где указывать своё видение будущего проекта и возможных изменений, а эти изменения и будут побуждать изучить какие-то дополнительные нюансы JAVA

13.12.17
	Нужно было сравнивать продукты и не хотелось заморачиваться с писаниной для сравнения каждого поля объекта, поэтому переопределил метод equals().
		При определении необходимо было сравнить ссылки на равенство, убедиться, что сслыка != null, что сравниваемые объекты одного типа, а затем создать экземпеляр сравниваемого объекта с типом вызывающего метод объекта и сравнить поля, идентифицирующие объект.
	Думал, что проблема при сравнении элементов массива с введеным объектом заключается в переопределенном методе equals(), но потом задал вопрос на slack по особенностям работы циклов for и for each.
		Оказалось, что for each работает с копиями элементов основного массива. Придется выборочно использовать циклы for и for each.

17.12.17
	Чтобы начать цикл заново, нужно использовать оператор continue.

21.12.17
	У класса Scanner есть метод .hasNextInt(), который вернет true, если с потока ввода можно считать целое число.
	Если после метода .nextInt() использовать метод .nextLine(), то метод .nextLine() считает последнее нажатие клавиши ENTER, как символ \n (перехода а новую строку). Поэтому после метода .nextInt() использовать метод .nextLine(), который считает нажатие клавиши ENTER и освободит буфер, а потом уже использовать метод .nextLine(), как задумывалось изначально.
	Метод .hasNextInt() можно использовать вместо использования исключений при проверке введеных пользователем данных.

07.01.18
	Maven установил через Homebrew(https://brew.sh/index_ru.html), введя в терминал комнду /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)". Потом руководствовался следующим http://www.apache-maven.ru/quick_start.html.
	При выполнении команды mvn compile выходила ошибка:
														Compilation failure: Compilation failure: 
														[ERROR] Source option 1.5 is no longer supported. Use 1.6 or later.
														[ERROR] Target option 1.5 is no longer supported. Use 1.6 or later.
														Эту проблему решил, добавив в pom.xml в теге <properties> следующие строки:
															<maven.compiler.source>1.6</maven.compiler.source>
    														<maven.compiler.target>1.6</maven.compiler.target>
    													И изменив название пакета с 1 на first
    При выполнении команды java -cp ./target/classes first.App все заработало.

07.01.18
	Создал проект maven в IDEA, нажав правой кнопкой мыши на имя проекта, потом выбрав New/Module/Maven.
	В корневом pom.xml добавил следующий тег:
												<dependencies>
											        <dependency>
											            <groupId>junit</groupId>
											            <artifactId>junit</artifactId>
											            <version>4.12</version>
											            <scope>test</scope>
											        </dependency>
											    </dependencies>
	Автоматически создали директории проекета maven. Меня интересовала директория test. В ней создал тестирующие классы с именами оригиналов + Test.
	Импортировал следующие библиотеки:
										import org.junit.Test;
										import static org.hamcrest.core.Is.is;
										import static org.junit.Assert.assertThat;

16.01.18
	Для освоения нового для себя направления решил изучить и использовать в своей программе некоторые структуры данных. Как оказалось есть несколько их видов: каждый из них эффективен в различных ситуациях. Соответственно встал вопрос: а какая у меня ситуация?

	Мне необходимо хранить что-то, что имеет описание и свой уникальный номер, порядок хранения не важен, элементы будут добавляться и удаляться, элементы нужно будет искать либо по точному описанию, либо по уникальному номеру.

	Решил, что подходящим способом хранения будет использование Map, а именно его реализацию в классе HashMap, т.к. расположение самих уникальных номеров и элементов по этим номерам не имеет значения.

21.01.18
	Забыл написать, как устанавливал Git к себе на Mac. Просто в терминале набрал xcode-select --install.
	Потом идет инициализация репозиория: имя_папки$ git init

	Осваиваю методы класса HashMap:

		Map<Integer, String> exampleHashMap = new HashMap();

        // добавление в множество пары ключ-значение
        exampleHashMap.put(1,"картошка");
        exampleHashMap.put(2,"морковка");

        System.out.println(exampleHashMap);

        // возвращает true, если коллекция содержит ключ k
        boolean beKey1 = exampleHashMap.containsKey(1);
        boolean beKey2 = exampleHashMap.containsKey(2);

        // возвращает true, если коллекция содержит значение v
        boolean beValuePotato = exampleHashMap.containsValue("картошка");

        // возвращает набор всех ключей множества
        Set keySet = exampleHashMap.keySet();

        // возвращает набор всех значений множества
        Collection values = exampleHashMap.values();
        

        System.out.println(beKey1 + " " + beKey2 + " " + beValuePotato + " " + keySet + " " + values);
    Столкнулся с тем, что в HashMap хранятся пары типа ключ-значение, а у меня продукт имеет следующие поля: имя, артикул, цена. Решил, что имя и артикул продукта будут парой ключ-значение, тогда, как поступить с ценой? Вот так: парой можно сделать продукт и его артикул, соответственно придется подумать, как под такую логику подогнать уже имеющуюся реализацию класса Product.

    	// удаляет объект с ключом k
        exampleHashMap.remove(potato.getId());

        // возвращает значение объекта, ключ которого равен k
        Product pot = exampleHashMap.get(potato.getId());
